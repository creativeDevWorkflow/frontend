# Redux Toolkit

## createSlice

```js
// npm install @reduxjs/toolkit
import { createSlice } from "@reduxjs/toolkit";
```

We typically define one reducer for each slice of the state. Those are called “slice reducers”.

```js
const options = {
  name: "todos",
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      return [
        ...state,
        {
          id: action.payload.id,
          text: action.payload.text,
          completed: false,
        },
      ];
    },
    toggleTodo: (state, action) => {
      return state.map((todo) =>
        todo.id === action.payload.id
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    },
  },
};

const todosSlice = createSlice(options);
```

`createSlice` receive `options` parameter.

- `name`: a string that is used as the prefix for generated action types.
- `initialState`: the initial state value for the reducer.
- `reducers`: (referred to as _case reducers_) an object of methods. The keys determine the action `type` strings, and the methods are the actualr educers.

With `createSlice()`...

- We can write the case reducers as functions inside of an object, instead of having to write a switch/case statement.
- Action creators that correspond to each case reducer function we provide will be automatically generated, so we don’t need to worry about defining those ourselves.
- No default handler needs to be written. The reducer generated by createSlice() will automatically handle all other action types by returning the current state, so we don’t have to list that ourselves.

Case Reducers:

- Each value in the `options.reducers` object should be a function whose name corresponds to an action type that the slice can handle.
- Each case reducer should have two parameters, `state` and `action`, and return the next state.

<br>

## Writing "Mutable" Code with Immer

Redux Toolkit’s `createSlice()` function uses a library called [Immer](https://immerjs.github.io/immer/) inside of it which helps avoid the mistake of accidentally mutating the state.

Immer uses a special JS object called a Proxy to wrap the data you provide and lets you write code that “mutates” that wrapped data. Immer does this by tracking all the changes you’ve made and then uses that list of changes to return an immutably updated value as if you’d written all the immutable update logic by hand.

```js
const todosSlice = createSlice({
  name: "todos",
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push({
        ...action.payload,
        completed: false,
      });
    },
    toggleTodo: (state, action) => {
      const todo = state.find((todo) => todo.id === action.payload.id);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
  },
});
```

`createSlice` uses immer and allow us to safely "mutate" the state.

<br>

## Return Object - Actions

What does `createSlice` return? An object that looks like this:

```js
/* Object returned by todosSlice */
{
 name: 'todos',
 reducer: (state, action) => newState,
 actions: {
   addTodo: (payload) => ({type: 'todos/addTodo', payload}),
   toggleTodo: (payload) => ({type: 'todos/toggleTodo', payload})
 },
 // case reducers field omitted
}
```

- `name` holds the value of the string that is used as the prefix for the generated action types.
- `reducer` is the complete reducer function.
- `actions` holds the the auto-generated action creators.

What do these auto-generated action objects look like?

By default, the action creator accepts one argument, which it puts into the action object as `action.payload`. The `action.type` string is generated for us by combining the slice’s name field with the `name` of the case reducer function.

```js
todosSlice.actions.addTodo("walk dog"); // {type: 'todos/addTodo', payload: 'walk dog'}
```

You’ll need to use the action creators in other files, so at a minimum you could export the entire slice object returned by `createSlice()`. However, we’ll use a Redux community code convention called the “ducks” pattern, which suggests that we use named exports for the action creators and export them separately from the reducer.

```js
export const { addTodo, toggleTodo } = todosSlice.actions;
```

<br>

## Return Object - Reducers

`reducer` in the return object of `createSlice`.

`todosSlice.reducer` is the complete reducer function, a.k.a the “slice reducer”.

When an action with the type `'todos/addTodo'` is dispatched, `todosSlice` will execute `todosSlice.reducer()` to check if the dispatched action’s `type` matches one of `todos.actions` case reducers. If so, it will run the matching case reducer function and if not, it will return the current state. This is exactly the same pattern that we had previously implemented with `switch` / `case` statements!

Finally, `todosSlice.reducer` needs to be exported so that it can be passed to the store and be used as the `todos` slice of state. While the `todosSlice.actions` are exported as named exports, the `todosSlice.reducer` value is used as the default export.

```js
export const { addTodo, toggleTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

<br>

## Converting the Store to Use `configureStore()`

[`configureStore()`](https://redux-toolkit.js.org/api/configureStore) accepts a single configuration object parameter.

The input object should have a reducer property that defines either a function to be used as the root reducer, or an object of slice reducers which will be combined to create a root reducer.

```js
import { configureStore } from "@reduxjs/toolkit";

import todosReducer from "./features/todos/todosSlice";
import filtersReducer from "./features/filters/filtersSlice";

const store = configureStore({
  reducer: {
    todos: todosReducer,
    filters: filtersReducer,
  },
});

export default store;
```

- It combines todosReducer and filtersReducer into the root reducer function, which will handle a root state that looks like {todos, filters}, removing the need to call combineReducers()
- It creates a Redux store using that root reducer, removing the need to call createStore()
- It automatically adds the thunk middleware (which you will learn about in the next lesson!)
- It automatically adds more middleware to check for common mistakes like accidentally mutating the state
- It automatically sets up the Redux DevTools Extension connection

We can just import the individual slice reducers straight into this file instead of creating a separate file for the root reducer and having to export/import it.
